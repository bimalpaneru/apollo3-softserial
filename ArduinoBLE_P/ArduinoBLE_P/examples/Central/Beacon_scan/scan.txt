Scanning peripherals with ArduinoBLE
====================================

There are 2 different options to obtain the scanned advertised data:
A. Set a Scan-Callback to handle advertised data
B. Check new peripheral advertising data as part of loop().

Both methodes have benefit and tradeoffs which are explained in this document.

How is scanned advertised data obtained ?
=========================================

The scan is performed by the Bluetooth HCI-layer, which is included in the processor chip.
In most cases this HCI-layer has an API that is equal to Bluetooth specification, version 4.2, volume 2,
part E, sections 7.8.1 through 7.8.46 (LE Controller commands). Additional vendor specific commands could
also available for operations such as setting the frame mode, setting sleep mode and other BLE Core
specific commands. The later differ vendor to vendor.

From the ArduinoBLE GAP-layer first the scan parameters are set for 10ms interval/window and to accept all scan.
The scan-enable-command will then be send and from this moment on the HCI layer will "stream" any received advertise
packet back to the HCI-interface of ArduinoBLE. There are different interfaces, depending on your board.
Here it is stored in a receive buffer. Depending on how often an Advertising packet is arriving, the receive buffer
will get multiple packets. Often the receive buffer is 256 bytes, where an advertising packet is max 31 bytes.

When a "BLE.poll" is performed, it will kick-off a read-loop to read all the data that is in the receive-buffer.
The received packaged is either an ACL or an event. An received advertisement is passed to GAP, handleLeAdvertisingReport().
If multiple packets have been stored in the receive buffer, they will all be handled with a single poll, untill all received
bytes are handled.

From handleLeAdvertisingReport the process is different in case of call-back or loop().

Scan without Callback
=====================

In this situation as part of the sketch loop() there is a check to see whether any new perpherial is available. If so,
it will handle / display that data and return in the loop().

So when 'BLE-poll' is called once from the sketch, a read-loop will be started as we have seen before. In handleLeAdvertisingReport()
for each packet received it will check in a pending-list whether we have just had an advertisement packet before from this peripheral device.
If not, it will create a new BLEDevice and add that to the list. If was in the list already that BLEDevice will be used.  Now it will copy the received advertised data to that device.
If multiple packets are within the receive buffer, the read-loop will read the next package. If that happens to be advertised data from the SAME peripheral it will overwrite what was there earlier. (no harm done) If it is a new  peripheral it will create a new BLEDevice, add to the pending-list and stored the advertised data in that new device.

From the sketch-loop() BLEDevice peripheral = BLE.available(); is called. This is transfered to the available() call in GAP. Here it will loop
through the list of pending-devices. If there is advertised data in that device, it will first check whether any filter was set and if so whether the
advertised data is meeting the filter criteria. If NO filter OR it meets the criteria that the pointer to that device is returned.
Also that device is removed from the pending-list and 'deleted'. The later looks tricky to me as the memory is then released while we still need to read it in the sketch.

There is a known issue that if scan is running for a longer time, it might stop providing new advertisement reports. The fix
for that was implemented (// https://github.com/arduino-libraries/ArduinoBLE/pull/264 fix BLE scanning block after minutes)
The root cause is that the maximum devices allowed in the pending-device-list is reached, (GAP_MAX_DISCOVERED_QUEUE_SIZE = 5), waiting to be handled. In that case the new scanned advertised data is dropped. The fix is to re-use the first entry of the pending-list in that case (so you loose an earlier discovered device). I wonder why the BLE.available() was not working ? Make sure to only start a "sleep" or "delay" in sketch-loop() UNLESS there is NO new peripheral available !

Scan with Callback
==================

A callback is set from the sketch with a the call : BLE.setEventHandler(BLEDiscovered, CALLBACK_ROUTINE);

When there is a callback set, the scanned advertise is data stored and then sketch is "pushed" to handle it NOW. Before calling the CALLBACK_ROUTINE, it will check whether any filter was set and if so whether the advertised data is meeting the filter criteria. If NO filter OR it meets the criteria the CALLBACK_ROUTINE will be called for each and every received advertising packet to handle. Even if that is an advertisement report from a device we JUST had before. Without a call-back it would overwrite it in the device from the pending-list with the same data, but now the call-back is called again. It feels like "hammering" the sketch.

During my tests, once a single 'BLE.poll' was called, the read-loop that was kicked-off hardly returned. It kept on reading from the receive buffer, calling handleLeAdvertisingReport(), which then called the CALLBACK_ROUTINE in the sketch and by the time all that has finished and returned, there was already another packet in the receive buffer to be handled. (often from the same peripheral device !!)
This can be observed with the Beacon Scanner. You will see that the keep-alive LED's will NOT blink, untill the scanner stalled.

With the 'speed of light' the scanned advertised / Beacon data scrolled on the screen. BUT only for max. 16 to 20 times on an Apollo3 board. Then it
got stuck. (Houston we got a hang !) The keep-alive led blinks, but no further response or information from the HCI layer was received. I have tried to find out WHY, the HCI-layer just would NOT generate anymore interrupts ot indicate any received data. It feels like it could not hand-off the received data on-time and caused a buffer overrun within the HCI-layer.
When running the exact same sketch on an nRF52840 there was no problem.

Conclusion
==========

Set a scan-call-back will have the potential for a continuous "hammer" on your sketch and not letting enough time to handle other tasks. The "pull", check for new device available, is much better, as long as you check enough the availability.

I have also implemented a filter function in the sketch. If a BEACON is discorved for the first time, the complete data will be display. Next time around
it will only display the UUID and RSSI, so you can start to determine the distance to the Beacon.
